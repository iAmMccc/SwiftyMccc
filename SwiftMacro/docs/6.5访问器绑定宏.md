# Swift Macros - è®¿é—®å™¨ç»‘å®šå®

åœ¨ Swift å®ä½“ç³»ä¸­ï¼Œ`AccessorMacro` æ˜¯ä¸€ç§ä¸“ç”¨äº**è‡ªåŠ¨ç”Ÿæˆå±æ€§è®¿é—®å™¨ï¼ˆå¦‚ getterã€setterã€willSetã€didSet ç­‰ï¼‰**çš„å®åè®®ã€‚å®ƒé€‚ç”¨äºé‚£äº›å¸Œæœ›å¯¹å±æ€§è®¿é—®è¡Œä¸ºè¿›è¡Œè‡ªå®šä¹‰ã€è·Ÿè¸ªæˆ–æ‰©å±•çš„åœºæ™¯ï¼Œåœ¨æ„å»ºå£°æ˜å¼å±æ€§æ¨¡å‹å’ŒçŠ¶æ€è§‚å¯Ÿç³»ç»Ÿä¸­æå…·ä»·å€¼ã€‚



## 1. `AccessorMacro` çš„å®šä¹‰

æ ‡å‡†åº“ä¸­ `AccessorMacro` çš„åè®®å®šä¹‰å¦‚ä¸‹ï¼š

```
public protocol AccessorMacro: AttachedMacro {
  static func expansion(
    of node: AttributeSyntax,
    providingAccessorsOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
  ) throws -> [AccessorDeclSyntax]
}
```

è¿™è¡¨ç¤ºï¼š

- å®ƒæ˜¯ä¸€ç§ `@attached(accessor)` ç±»å‹çš„å®ï¼›
- ä¸“é—¨ç”¨äº**å±æ€§çº§åˆ«ï¼ˆproperty-levelï¼‰**ç»‘å®šï¼›
- å®ƒçš„è¿”å›å€¼ä¸º `[AccessorDeclSyntax]`ï¼Œå³è®¿é—®å™¨æ•°ç»„ï¼›
- ä¸ `MemberMacro` ä¸åŒï¼Œå®ƒä¸ç”Ÿæˆæ–°æˆå‘˜ï¼Œåªç”Ÿæˆè¯¥å±æ€§çš„è®¿é—®é€»è¾‘ã€‚





## 2. ç¤ºä¾‹ï¼šä¸€æ­¥æ­¥æ„å»º `@UserDefault` å®

å®çš„æœ€å¤§é­…åŠ›ï¼Œåœ¨äºâ€œç”¨ç®€å•çš„è¯­æ³•ï¼Œç”Ÿæˆå¤æ‚ä½†é‡å¤çš„ä»£ç â€ã€‚æˆ‘ä»¬ä»¥ä¸‹é¢è¿™ä¸ªä¾‹å­ä¸ºç›®æ ‡ï¼Œä¸€æ­¥æ­¥å®ç°å®ƒèƒŒåçš„å®é€»è¾‘ã€‚

### æƒ³è¦çš„ç›®æ ‡æ•ˆæœ

```
struct Setting {
    
    @UserDefault
    var name: String?

    @UserDefault(forKey: "customKey")
    var age: Int = 111
}
```

å±•å¼€ä¸ºï¼š

```
struct Setting {

    var name: String {
        get {
            UserDefaults.standard.value(forKey: "name") as? String
        }
        set {
            UserDefaults.standard.setValue(newValue, forKey: "name")
        }
    }
    var age: Int {
        get {
            UserDefaults.standard.value(forKey: "customKey") as? Int ?? 111
        }
        set {
            UserDefaults.standard.setValue(newValue, forKey: "customKey")
        }
    }
}
```

å®ç°æ­¥éª¤ç´¢å¼•ï¼šæ„å»º `@UserDefault` å®çš„å®Œæ•´æµç¨‹

1. **å£°æ˜å®å…¥å£**
   - ä½¿ç”¨ `@attached(accessor)` æ ‡è®°ï¼›
   - è®¾ç½® `names: arbitrary` æ”¯æŒä»»æ„è®¿é—®å™¨åç§°ï¼›
   - æä¾› `forKey` å¯é€‰å‚æ•°ã€‚
2. **æå–å®å‚æ•°**
   - ä» `AttributeSyntax` ä¸­è§£æ `forKey`ï¼›
   - å¦‚æœæœªæŒ‡å®šï¼Œä½¿ç”¨å˜é‡åä½œä¸ºé»˜è®¤ keyã€‚
3. **è§£æå±æ€§å®šä¹‰**
   - è·å–å˜é‡åã€ç±»å‹ã€å¯é€‰æ€§ï¼›
   - è·å–é»˜è®¤å€¼è¡¨è¾¾å¼ï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼›
   - åˆ¤æ–­ç±»å‹æ˜¯å¦ä¸º Optionalã€‚
4. **ç”Ÿæˆ getter å®ç°**
   - æ‹¼æ¥ `UserDefaults.standard.value(forKey:) as? Type`ï¼›
   - æ ¹æ®å¯é€‰æ€§å’Œé»˜è®¤å€¼å†³å®šæ˜¯å¦è¿½åŠ  `?? defaultValue` æˆ– `!`ã€‚
5. **ç”Ÿæˆ setter å®ç°**
   - ç»Ÿä¸€æ ¼å¼ä¸º `UserDefaults.standard.setValue(newValue, forKey:)`ã€‚
6. **è¿”å›è®¿é—®å™¨æ•°ç»„**
   - è¿”å› `[AccessorDeclSyntax]` åŒ…å« getter å’Œ setterã€‚

### ç¬¬ä¸€æ­¥ï¼šå£°æ˜å®å…¥å£

```
@attached(accessor, names: arbitrary)
public macro UserDefault() = #externalMacro(
    module: "McccMacros",
    type: "UserDefaultMacro"
)
```

* `forKey` æ˜¯å¯é€‰å‚æ•°ï¼Œç”¨äºæŒ‡å®šè‡ªå®šä¹‰çš„ keyï¼›

* `names: arbitrary` è¡¨ç¤ºç”Ÿæˆçš„è®¿é—®å™¨ä¸å¼ºåˆ¶é™å®šåç§°ã€‚



###  ç¬¬äºŒæ­¥ï¼šæµ‹è¯•å•å…ƒ

> ğŸ’¡ **å»ºè®®ï¼šä½¿ç”¨å•å…ƒæµ‹è¯•é©±åŠ¨å¼€å‘**
>
> å®çš„è°ƒè¯•ä¸åŒäºæ™®é€šå‡½æ•°ï¼Œå®ƒç›´æ¥å½±å“è¯­æ³•ç»“æ„çš„å±•å¼€ç»“æœã€‚å› æ­¤å»ºè®®é‡‡ç”¨ **â€œå•å…ƒæµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTest-Driven Macro Developmentï¼‰â€** çš„æ–¹å¼æ¨è¿›ï¼Œå³ï¼š
>
> - å†™ä¸‹ä¸€ä¸ªä½ å¸Œæœ›å®æœ€ç»ˆå±•å¼€çš„ä½¿ç”¨æ¡ˆä¾‹ï¼›
> - ä½¿ç”¨ `assertMacroExpansion(...)` è¿›è¡Œæ–­è¨€ï¼›
> - æ ¹æ®æµ‹è¯•æŠ¥é”™é€æ­¥å®Œå–„å®é€»è¾‘ï¼›
> - æ¯ä¸€æ­¥ä¿®æ”¹éƒ½ç«‹åˆ»éªŒè¯æ•ˆæœã€‚
>
> è¿™ç§æ–¹å¼å¯ä»¥å¸®åŠ©ä½ ï¼š
>
> - å¿«é€Ÿæ•æ‰è¯­æ³•æ ‘å¤„ç†ä¸­çš„åå·®ï¼›
> - èšç„¦å…·ä½“ç›®æ ‡è€Œéé™·å…¥æŠ½è±¡è®¾è®¡ï¼›
> - åœ¨é‡æ„é€»è¾‘æ—¶ç¡®ä¿ä¸ç ´åå·²æœ‰è¡Œä¸ºã€‚
>
> æ¢å¥è¯è¯´ï¼Œè®©æµ‹è¯•å¸®ä½ â€œå¼•å¯¼å®çš„æˆé•¿â€ã€‚

```
func testMacroWithUserDefault() throws {
    assertMacroExpansion(
        #"""
        struct Setting {
            
            @UserDefault
            var name: String = "Mccc"
        
            @UserDefault(forKey: "customKey")
            var age: Int = 111
        }
        
        """#,
        expandedSource: #"""
        struct Setting {
        
            var name: String {
                get {
                    UserDefaults.standard.value(forKey: "name") as? String ?? "Mccc"
                }
                set {
                    UserDefaults.standard.setValue(newValue, forKey: "name")
                }
            }
            var age: Int {
                get {
                    UserDefaults.standard.value(forKey: "customKey") as? Int ?? 111
                }
                set {
                    UserDefaults.standard.setValue(newValue, forKey: "customKey")
                }
            }
        }
        """#,
        macros: testMacros
    )
}
```



### ç¬¬ä¸‰æ­¥ï¼šå®ç°å®é€»è¾‘

```
public struct UserDefaultMacro: AccessorMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingAccessorsOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [AccessorDeclSyntax] {
        return []
    }
}
```

#### contextå‚æ•°

å‰é¢ç« èŠ‚å·²è¯¦ç»†è¯´æ˜è¿‡ï¼Œä¸å†é˜è¿°ã€‚

#### nodeå‚æ•°

```
(lldb) po node
AttributeSyntax
â”œâ”€atSign: atSign
â•°â”€attributeName: IdentifierTypeSyntax
  â•°â”€name: identifier("UserDefault")
```

`node` æ˜¯ **å½“å‰è¿™ä¸ªå±æ€§ä¸Šä½¿ç”¨çš„å®ï¼ˆattributeï¼‰æœ¬èº«çš„è¯­æ³•æ ‘ç»“æ„**ã€‚

ä¸¾ä¸ªä¾‹å­ï¼š

```
@UserDefault(forKey: "customKey", value: "customValue")
var age: Int
```

 `node` è¡¨ç¤ºçš„å°±æ˜¯è¿™æ•´æ®µï¼š

```
@UserDefault(forKey: "customKey", value: "customValue")
```

 æ­¤æ—¶çš„nodeæ˜¯ï¼š

```
AttributeSyntax
â”œâ”€atSign: atSign
â”œâ”€attributeName: IdentifierTypeSyntax
â”‚ â•°â”€name: identifier("UserDefault")
â”œâ”€leftParen: leftParen
â”œâ”€arguments: LabeledExprListSyntax
â”‚ â”œâ”€[0]: LabeledExprSyntax
â”‚ â”‚ â”œâ”€label: identifier("forKey")
â”‚ â”‚ â”œâ”€colon: colon
â”‚ â”‚ â”œâ”€expression: StringLiteralExprSyntax
â”‚ â”‚ â”‚ â”œâ”€openingQuote: stringQuote
â”‚ â”‚ â”‚ â”œâ”€segments: StringLiteralSegmentListSyntax
â”‚ â”‚ â”‚ â”‚ â•°â”€[0]: StringSegmentSyntax
â”‚ â”‚ â”‚ â”‚   â•°â”€content: stringSegment("customKey")
â”‚ â”‚ â”‚ â•°â”€closingQuote: stringQuote
â”‚ â”‚ â•°â”€trailingComma: comma
â”‚ â•°â”€[1]: LabeledExprSyntax
â”‚   â”œâ”€label: identifier("value")
â”‚   â”œâ”€colon: colon
â”‚   â•°â”€expression: StringLiteralExprSyntax
â”‚     â”œâ”€openingQuote: stringQuote
â”‚     â”œâ”€segments: StringLiteralSegmentListSyntax
â”‚     â”‚ â•°â”€[0]: StringSegmentSyntax
â”‚     â”‚   â•°â”€content: stringSegment("customValue")
â”‚     â•°â”€closingQuote: stringQuote
â•°â”€rightParen: rightParen
```

| æˆå‘˜å­—æ®µ        | è¯´æ˜                                               |
| --------------- | -------------------------------------------------- |
| `atSign`        | `@` ç¬¦å·ï¼ˆTokenSyntaxï¼‰                            |
| `attributeName` | å®çš„åå­—ï¼Œå¦‚ `UserDefault`ï¼ˆIdentifierTypeSyntaxï¼‰ |
| `leftParen`     | å·¦æ‹¬å· `(`ï¼ˆå¯é€‰ï¼‰                                 |
| `arguments`     | æ‹¬å·å†…çš„å‚æ•°åˆ—è¡¨ï¼ˆ`LabeledExprListSyntax`ï¼‰        |
| `rightParen`    | å³æ‹¬å· `)`ï¼ˆå¯é€‰ï¼‰                                 |

#### declarationå‚æ•°

```
(lldb) po declaration
VariableDeclSyntax
â”œâ”€attributes: AttributeListSyntax
â”‚ â•°â”€[0]: AttributeSyntax
â”‚   â”œâ”€atSign: atSign
â”‚   â•°â”€attributeName: IdentifierTypeSyntax
â”‚     â•°â”€name: identifier("UserDefault")
â”œâ”€modifiers: DeclModifierListSyntax
â”œâ”€bindingSpecifier: keyword(SwiftSyntax.Keyword.var)
â•°â”€bindings: PatternBindingListSyntax
  â•°â”€[0]: PatternBindingSyntax
    â”œâ”€pattern: IdentifierPatternSyntax
    â”‚ â•°â”€identifier: identifier("name")
    â”œâ”€typeAnnotation: TypeAnnotationSyntax
    â”‚ â”œâ”€colon: colon
    â”‚ â•°â”€type: IdentifierTypeSyntax
    â”‚   â•°â”€name: identifier("String")
    â•°â”€initializer: InitializerClauseSyntax
      â”œâ”€equal: equal
      â•°â”€value: StringLiteralExprSyntax
        â”œâ”€openingQuote: stringQuote
        â”œâ”€segments: StringLiteralSegmentListSyntax
        â”‚ â•°â”€[0]: StringSegmentSyntax
        â”‚   â•°â”€content: stringSegment("Mccc")
        â•°â”€closingQuote: stringQuote
```



#### å¼€å§‹å®ç°

* è·å–å±æ€§åå’Œç±»å‹

  ```
  // è·å–å±æ€§åå’Œå±æ€§ç±»å‹
  guard let varDecl = declaration.as(VariableDeclSyntax.self),
        let binding = varDecl.bindings.first,
        let name = binding.pattern.as(IdentifierPatternSyntax.self)?.identifier.text,
        let typeSyntax = binding.typeAnnotation?.type else {
      fatalError()
  }
  ```

* åˆ¤æ–­æ˜¯å¦å¯é€‰ï¼Œè·å–è§£åŒ…ç±»å‹

  ```
  // åˆ¤æ–­æ˜¯å¦å¯é€‰ & è·å–è§£åŒ…ç±»å‹
  var unWrapType = typeSyntax
  var isOptional = false
  
  if let optionalType = typeSyntax.as(OptionalTypeSyntax.self) {
      isOptional = true
      unWrapType = optionalType.wrappedType
  }
  ```

* è·å–åˆå§‹åŒ–å€¼

  ```
  // è·å–åˆå§‹åŒ–å€¼
  let initValue = binding.initializer?.value.trimmedDescription
  ```

* è·å–å­˜å‚¨çš„key

  ```
  static func extractUserDefaultKey(from node: AttributeSyntax, fallback proertyName: String) -> String {
      guard let arguments = node.arguments?.as(LabeledExprListSyntax.self) else { return proertyName }
  
      for arg in arguments {
          if let expression = arg.expression.as(StringLiteralExprSyntax.self) {
              if let content = expression.segments.first?.as(StringSegmentSyntax.self)?.content.text {
                 return content
              }
          }
      }
      return proertyName
  }
  ```

  

* å®ç°getæ–¹æ³•

  ```
  var getter: AccessorDeclSyntax
  if isOptional {
      getter = """
      get {
         UserDefaults.standard.value(forKey: "\(raw: name)") as? \(raw: unWrapType)
      }
      """
  } else {
      getter = """
      get {
         UserDefaults.standard.value(forKey: "\(raw: name)") as? \(raw: unWrapType) ?? \(raw: initValue!)
      }
      """
  }
  ```

  

* å®ç°setæ–¹æ³•

  ```
  let setter = AccessorDeclSyntax(
      """
      set {
          UserDefaults.standard.setValue(newValue, forKey: "\(raw: saveKey)")
      }
      """
  )
  ```

* è¿”å›æ–¹æ³•

  ```
  return [getter, setter]
  ```



### å®Œæ•´çš„ä»£ç 

```
@attached(accessor, names: arbitrary)
public macro UserDefault(forKey: String? = nil) = #externalMacro(
    module: "TestMacroMacros",
    type: "UserDefaultMacro"
)

public struct UserDefaultMacro: AccessorMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingAccessorsOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [AccessorDeclSyntax] {
    
        // è·å–å±æ€§åå’Œå±æ€§ç±»å‹
        guard let varDecl = declaration.as(VariableDeclSyntax.self),
              let binding = varDecl.bindings.first,
              let name = binding.pattern.as(IdentifierPatternSyntax.self)?.identifier.text,
              let typeSyntax = binding.typeAnnotation?.type else {
            fatalError()
        }
        
        // åˆ¤æ–­æ˜¯å¦å¯é€‰ & è·å–è§£åŒ…ç±»å‹
        var unWrapType = typeSyntax
        var isOptional = false
        
        if let optionalType = typeSyntax.as(OptionalTypeSyntax.self) {
            isOptional = true
            unWrapType = optionalType.wrappedType
        }
        
       // è·å–å­˜å‚¨key
        let saveKey = extractUserDefaultKey(from: node, fallback: name)
        
        // è·å–åˆå§‹åŒ–å€¼
        let initValue = binding.initializer?.value.trimmedDescription
        
        // æ„é€  getter
        var getter: AccessorDeclSyntax
        if isOptional {
            getter = """
            get {
               UserDefaults.standard.value(forKey: "\(raw: name)") as? \(raw: unWrapType)
            }
            """
        } else {
            getter = """
            get {
               UserDefaults.standard.value(forKey: "\(raw: name)") as? \(raw: unWrapType) ?? \(raw: initValue!)
            }
            """
        }
        
        // æ„é€  setter
        let setter = AccessorDeclSyntax(
            """
            set {
                UserDefaults.standard.setValue(newValue, forKey: "\(raw: saveKey)")
            }
            """
        )
        
        return [getter, setter]
    }
    
    /// è·å–å­˜å‚¨çš„key
    static func extractUserDefaultKey(from node: AttributeSyntax, fallback proertyName: String) -> String {
        guard let arguments = node.arguments?.as(LabeledExprListSyntax.self) else { return proertyName }

        for arg in arguments {
            if let expression = arg.expression.as(StringLiteralExprSyntax.self) {
                if let content = expression.segments.first?.as(StringSegmentSyntax.self)?.content.text {
                   return content
                }
            }
        }
        return proertyName
    }
}
```



## 3. å‚æ•°è¯¦è§£

Swift å®ä¸­çš„ `accessor` ç±»å‹å¸¸ä½¿ç”¨ä»¥ä¸‹ä¸‰ä¸ªå‚æ•°ï¼š`node`ã€`declaration` å’Œ `context`ã€‚

æœ¬èŠ‚å°†é€ä¸€è¯¦è§£å…¶å«ä¹‰ä¸å…¸å‹ç»“æ„ï¼Œå¸®åŠ©ä½ æ›´æ·±å…¥ç†è§£å®å±•å¼€è¿‡ç¨‹ä¸­çš„è¯­æ³•èŠ‚ç‚¹ä¼ é€’æœºåˆ¶ã€‚

### `of node: AttributeSyntax`

`node` è¡¨ç¤ºå½“å‰ä½¿ç”¨åœ¨å±æ€§ä¸Šçš„å®æ ‡è®°æœ¬èº«ï¼Œå…¶ç±»å‹ä¸º `AttributeSyntax`ï¼Œå³ **ä¿®é¥°è¯¥å±æ€§çš„å®è°ƒç”¨è¯­æ³•ç»“æ„**ã€‚

#### ç¤ºä¾‹

```
@UserDefault(forKey: "customKey", value: "customValue")
var age: Int
```

æ­¤æ—¶ï¼Œ`node` æŒ‡å‘çš„å°±æ˜¯æ•´æ®µå®è°ƒç”¨éƒ¨åˆ†ï¼š

```
@UserDefault(forKey: "customKey", value: "customValue")
```

å…¶è¯­æ³•ç»“æ„å¦‚ä¸‹ï¼ˆç®€åŒ–å±•ç¤ºï¼‰ï¼š

```
AttributeSyntax
â”œâ”€atSign: @
â”œâ”€attributeName: UserDefault
â”œâ”€leftParen: (
â”œâ”€arguments: LabeledExprListSyntax
â”‚ â”œâ”€forKey: "customKey"
â”‚ â””â”€value: "customValue"
â””â”€rightParen: )
```

ä½ å¯ä»¥é€šè¿‡è§£æ `node.arguments` æ¥æå–å®ä¸­çš„å…·ä½“å‚æ•°å€¼ï¼Œå¦‚ `forKey` å’Œ `value`ã€‚é€šå¸¸æˆ‘ä»¬ä¼šè¿™æ ·å¤„ç†ï¼š

```
if let arguments = node.argument?.as(LabeledExprListSyntax.self) {
    for argument in arguments {
        let label = argument.label?.text
        let expr = argument.expression
        ...
    }
}
```

#### å¸¸è§æˆå‘˜å­—æ®µè¯´æ˜

| å­—æ®µå          | ç±»å‹                     | æè¿°                                                        |
| --------------- | ------------------------ | ----------------------------------------------------------- |
| `atSign`        | `TokenSyntax`            | ä»£è¡¨å®çš„ `@` å‰ç¼€ç¬¦å·                                       |
| `attributeName` | `TypeSyntax`             | å®çš„åç§°ï¼Œä¾‹å¦‚ `UserDefault`ï¼Œé€šå¸¸ä¸º `IdentifierTypeSyntax` |
| `leftParen`     | `TokenSyntax?`           | å·¦æ‹¬å· `(`ï¼Œå¯é€‰ï¼ˆå½“å®æ— å‚æ•°æ—¶ä¸º nilï¼‰                      |
| `arguments`     | `LabeledExprListSyntax?` | æ‹¬å·å†…çš„å‚æ•°åˆ—è¡¨ï¼ŒåŒ…å«å¤šä¸ª `LabeledExprSyntax`              |
| `rightParen`    | `TokenSyntax?`           | å³æ‹¬å· `)`ï¼Œå¯é€‰                                            |



------

### `providingAccessorsOf declaration: some DeclSyntaxProtocol`

`declaration` æ˜¯å®æ‰€é™„åŠ çš„ç›®æ ‡å£°æ˜ï¼Œå³ä½ å¸Œæœ›ä¸ºå…¶ç”Ÿæˆè®¿é—®å™¨ï¼ˆgetter/setterï¼‰çš„å˜é‡å£°æ˜æœ¬ä½“ã€‚

é€šå¸¸æ˜¯ä¸€ä¸ª `VariableDeclSyntax`ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢ä¾‹å­ä¸­çš„ï¼š

```
var age: Int = 0
```

è¿™æ„å‘³ç€ä½ å¯ä»¥åœ¨å®ä¸­è§£æè¯¥å˜é‡çš„åç§°ã€ç±»å‹ã€å¯é€‰æ€§ä»¥åŠé»˜è®¤å€¼ç­‰ä¿¡æ¯ï¼Œä»è€Œè‡ªåŠ¨æ„é€ è®¿é—®å™¨å‡½æ•°ã€‚

ğŸ’¡ ä¸ `attachedTo` çš„ä½œç”¨ç›¸è¿‘ï¼Œä½† `providingAccessorsOf` æ›´å¼ºè°ƒ **ä½ æ­£åœ¨ä¸ºè¿™ä¸ªå£°æ˜â€œæä¾›è®¿é—®å™¨â€**ï¼Œè¯­ä¹‰æ›´èšç„¦äº accessor åœºæ™¯ã€‚



### `in context: some MacroExpansionContext`

`context` æä¾›å½“å‰å®å±•å¼€çš„ä¸Šä¸‹æ–‡ç¯å¢ƒï¼Œç”¨äºï¼š

- ç”Ÿæˆå”¯ä¸€çš„æ ‡è¯†ç¬¦ï¼ˆ`context.makeUniqueName(_:)`ï¼‰
- å®šä½å½“å‰æºç ä½ç½®ï¼ˆå¦‚ç”¨äºè¯Šæ–­æˆ–æ’å…¥ä»£ç ï¼‰
- æŠ›å‡ºç¼–è¯‘æœŸé”™è¯¯ï¼ˆé€šè¿‡ `context.diagnose(...)`ï¼‰
- è·å–æ­£åœ¨å±•å¼€çš„æºæ–‡ä»¶è·¯å¾„ã€æ¨¡å—åç­‰å…ƒä¿¡æ¯

è¿™æ˜¯ä¸€ä¸ªå·¥å…·æ€§è´¨çš„å‚æ•°ï¼Œæ˜¯æ„å»ºå®é€»è¾‘ä¸å¯æˆ–ç¼ºçš„è¾…åŠ©å™¨ã€‚



## . é™åˆ¶ä¸æ³¨æ„äº‹é¡¹

- è®¿é—®å™¨å®åªèƒ½é™„ç€åœ¨ `var` å±æ€§ä¸Šï¼›
- ä¸èƒ½ç”Ÿæˆ `willSet` å’Œ `didSet` ä¸ `get/set` åŒæ—¶å­˜åœ¨çš„æ··åˆè®¿é—®å™¨ï¼ˆSwift è¯­æ³•é™åˆ¶ï¼‰ï¼›
- åŸå§‹å±æ€§å¿…é¡»æœ‰ backing å­˜å‚¨ï¼ˆå¯é…åˆ `PeerMacro` ç”Ÿæˆï¼‰ï¼›
- ä¸ `@propertyWrapper` ä¸åŒï¼Œå®ƒä¸ä¼šå¼•å…¥é¢å¤–ç±»å‹æˆ–è¯­ä¹‰è´Ÿæ‹…ã€‚



## 5. æ€»ç»“

`AccessorMacro` æ˜¯ Swift å®ç³»ç»Ÿä¸­æ§åˆ¶â€œå±æ€§è¡Œä¸ºâ€çš„å…³é”®å·¥å…·ã€‚å®ƒé€šè¿‡è®¿é—®å™¨ä»£ç ç”Ÿæˆæœºåˆ¶ï¼Œå°†å±æ€§è¯­ä¹‰ä¸è¡Œä¸ºè§£è€¦ï¼Œé€‚ç”¨äºï¼š

- ç›‘å¬å±æ€§å˜åŒ–ï¼›
- æ„å»ºæ•°æ®æµå“åº”é€»è¾‘ï¼›
- æ‰§è¡Œèµ‹å€¼çº¦æŸä¸å¤„ç†ã€‚

ç»“åˆ `MemberMacro`ã€`PeerMacro`ï¼Œä½ å¯ä»¥æ„å»ºå‡ºå®Œæ•´çš„å£°æ˜å¼çŠ¶æ€æ¨¡å‹ç³»ç»Ÿï¼Œå®ç°çœŸæ­£çš„ç»“æ„é©±åŠ¨å¼ç¼–ç¨‹ä½“éªŒã€‚
