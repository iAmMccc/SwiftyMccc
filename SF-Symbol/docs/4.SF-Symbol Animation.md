# SF Symbol - 动画

<table>
<tr>
<td width="20%">
  <img src="../images/动画演示.gif" width="100%">
</td>
<td width="100%">
  <strong>Symbol Effect</strong> 
    <p>在 iOS 17 及更高版本中，Apple 为 SF Symbols 引入了全新的 符号动画（Symbol Effects）。
这些动画不同于传统视图动画（缩放、平移、旋转），而是直接作用于符号图层或可变部分，让图标本身具有动态表现，例如呼吸、闪烁、渐变、过渡等效果。</p>
  <strong>通过符号动画，开发者无需手动编写复杂的 Core Animation，就能让系统图标“活”起来。例如：</strong>
  <ul>
    <li>Wi-Fi 图标逐格点亮，模拟信号扫描；</li>
    <li>下载箭头闪动，提示任务进行中；</li>
    <li>电池、播放键、铃铛等符号在状态变化时带有自然过渡。</li>
  </ul>
</td>
</tr>
</table>

## 动画分类

### 表 1：符号动画协议分类

下表展示了 Apple 将符号动画（Symbol Effects）划分的 **四大协议类型**，并说明了每类动画的特点与适用场景：

| 动画类型               | 中文名称     | 协议名称                        | 特点与适用场景                                               |
| ---------------------- | ------------ | ------------------------------- | ------------------------------------------------------------ |
| **Discrete**           | 离散动画     | `DiscreteSymbolEffect`          | **一次性播放**，执行完立即停止。常用于 **点击反馈、瞬时提示**，例如按钮被点按时符号弹跳。 |
| **Indefinite**         | 无限动画     | `IndefiniteSymbolEffect`        | **持续循环**，直到主动移除。常用于 **常驻状态指示**，例如 Wi-Fi 信号波动、加载中的旋转。 |
| **Transition**         | 过渡动画     | `TransitionSymbolEffect`        | **符号状态切换时**触发，从一个符号过渡到另一个符号，带有平滑过渡效果。常用于 **出现 / 消失 动画**。 |
| **Content Transition** | 内容过渡动画 | `ContentTransitionSymbolEffect` | **符号内容替换时**触发，不仅是状态切换，而是图标本身的替换。例如 **播放按钮 → 暂停按钮** 的替换过程。 |

### 表 2：动画效果总览

下表展示了常见的 **具体动画效果**，对应的实现协议，以及常见的使用场景。相比上表的分类，这里更贴近开发者在实际项目中调用的具体效果：

| 动画               | 中文名称 | 对应协议                    | 典型使用场景                 |
| ------------------ | -------- | --------------------------- | ---------------------------- |
| **Bounce**         | 弹跳     | `BounceSymbolEffect`        | 图标提示、强调操作反馈       |
| **Pulse**          | 脉动     | `PulseSymbolEffect`         | 心跳、提醒、消息闪动         |
| **Breathe**        | 呼吸     | `BreatheSymbolEffect`       | 常驻状态提示（心跳、同步中） |
| **Rotate**         | 旋转     | `RotateSymbolEffect`        | 加载中、刷新中               |
| **Variable Color** | 颜色变化 | `VariableColorSymbolEffect` | 状态高亮、注意力引导         |
| **Wiggle**         | 摇摆     | `WiggleSymbolEffect`        | 输入错误提示、需要关注的 UI  |
| **Scale**          | 缩放     | `ScaleSymbolEffect`         | 持续缩放提醒、呼吸替代       |
| **Appear**         | 出现过渡 | `AppearSymbolEffect`        | 符号出现时的过渡效果         |
| **Disappear**      | 消失过渡 | `DisappearSymbolEffect`     | 符号消失时的过渡效果         |
| **Replace**        | 替换过渡 | `ReplaceSymbolEffect`       | 状态切换、图标替换时         |

### 表 3：协议支持矩阵

下表用矩阵形式列出了 **每种具体动画效果** 与 **协议类型** 的对应关系，开发者可以快速查找某个动画是否支持 **离散播放、无限循环、过渡动画或内容替换动画**：

| 动画               | Discrete | Indefinite | Transition | Content Transition |
| ------------------ | -------- | ---------- | ---------- | ------------------ |
| **Bounce**         | ✅        | ✅          |            |                    |
| **Pulse**          | ✅        | ✅          |            |                    |
| **Breathe**        | ✅        | ✅          |            |                    |
| **Rotate**         | ✅        | ✅          |            |                    |
| **Variable Color** | ✅        | ✅          |            |                    |
| **Wiggle**         | ✅        | ✅          |            |                    |
| **Scale**          |          | ✅          |            |                    |
| **Appear**         |          | ✅          | ✅          |                    |
| **Disappear**      |          | ✅          | ✅          |                    |
| **Replace**        |          |            |            | ✅                  |







## addSymbolEffect API

UIKit 提供了便捷的调用接口，主要用于 **UIImageView** 和 **UIBarButtonItem**：

```
imageView.addSymbolEffect(.bounce)
```

`addSymbolEffect` 的重载方法：

```Swift
@MainActor @preconcurrency 
public func addSymbolEffect(
   _ effect: some DiscreteSymbolEffect & SymbolEffect, 
   options: SymbolEffectOptions = .default, 
   animated: Bool = true, 
   completion: UISymbolEffectCompletion? = nil
)

@MainActor @preconcurrency 
public func addSymbolEffect(
  _ effect: some IndefiniteSymbolEffect & SymbolEffect, 
  options: SymbolEffectOptions = .default, 
  animated: Bool = true, 
  completion: UISymbolEffectCompletion? = nil
)

@MainActor @preconcurrency 
public func addSymbolEffect(
  _ effect: some DiscreteSymbolEffect & IndefiniteSymbolEffect & SymbolEffect, 
  options: SymbolEffectOptions = .default, 
  animated: Bool = true, 
  completion: UISymbolEffectCompletion? = nil
)
```

这些重载方法的`effect`涉及一个配置项 和 三个重要的协议： **DiscreteSymbolEffect**、**IndefiniteSymbolEffect** 和 **SymbolEffect**。这里也体现了Swift Protocol 强大的能力。 

### 1. 动画特性协议

```
public protocol SymbolEffect : Hashable, Sendable {
    var configuration: SymbolEffectConfiguration { get }
}
```

**定位**：`SymbolEffect` 是 **所有符号动画的公共抽象协议**。

**作用**：

- 抽离出动画的 **配置能力**，比如重复次数、延迟、作用层级等。
- 统一动画在 UIKit / SwiftUI 中的调用接口（如 `addSymbolEffect()`、`.symbolEffect()` 等）。

**注意**：它本身不定义动画行为，也不控制循环或持续时间，只提供“描述和配置”能力。



**具体的动画类型**（如 `BounceSymbolEffect`、`PulseSymbolEffect`、`VariableColorSymbolEffect`、`AppearSymbolEffect` 等）继承 **SymbolEffect**，再各自实现不同的 **功能性协议**。

```
public struct BounceSymbolEffect : SymbolEffect {

    public var up: BounceSymbolEffect { get }
    public var down: BounceSymbolEffect { get }
    public var byLayer: BounceSymbolEffect { get }
    public var wholeSymbol: BounceSymbolEffect { get }
    
    // 继承SymbolEffect获得的配置能力
    public var configuration: SymbolEffectConfiguration { get }
    
    ......
}
```



### 2. 动画执行协议

 ```
 public protocol DiscreteSymbolEffect {}
 public protocol IndefiniteSymbolEffect {}
 
 extension BounceSymbolEffect : IndefiniteSymbolEffect { }
 extension BounceSymbolEffect : DiscreteSymbolEffect { }
 ```

**定位**：这两个协议 **控制动画的生命周期特性**。

**作用**：

- `DiscreteSymbolEffect`： **一次性动画**（瞬态动画），只播放一次或播放固定次数，如 Appear / Disappear。
- `IndefiniteSymbolEffect`： **持续动画**（无限循环），直到被移除或禁用，如 Pulse / Bounce / VariableColor。

这就是为什么 `PulseSymbolEffect` 可以同时 conform 两个协议：它既可以作为一次性触发，也可以作为无限循环，取决于 `addSymbolEffect()` 调用时的配置。



### 3. SymbolEffectOptions

`SymbolEffectOptions` 提供了 **符号动画播放的策略和控制**，主要包括：

1. **速度控制（Speed）**
2. **重复控制（Repeat / RepeatBehavior）**
3. **默认值与预置（default、repeating、nonRepeating）**

它本身是 **值类型**（struct），并 conform `Hashable` / `Sendable`，可以安全地用于比较、存储和并发环境。

#### 1. 速度控制（Speed）

动画播放的快慢可以通过 `speed` 来控制：

```
// 创建一组 options，并设置播放速度为原来的 2 倍
let options = SymbolEffectOptions.speed(2.0)

// 或者在已有 options 上修改
let newOptions = options.speed(0.5) // 半速播放
```

- 默认速度为 `1.0`
- 值越大，动画播放越快；值越小，动画播放越慢
- 系统会对极端值进行限制（clamping）

------

#### 2. 重复控制

`SymbolEffectOptions` 还控制动画的重复行为：

##### 旧 API（iOS 17）

- `.repeat(_ count: Int?)`：指定播放次数
- `.repeating`：无限循环
- `.nonRepeating`：只播放一次

```
// 播放 3 次
let options = SymbolEffectOptions.repeat(3)

// 无限循环
let options2 = SymbolEffectOptions.repeating
```

##### 新 API（iOS 18+）

Apple 引入了更灵活的 **RepeatBehavior**：

```
@available(iOS 18.0, *)
SymbolEffectOptions.RepeatBehavior {
    // 使用周期性动画，无限循环
    static var periodic: SymbolEffectOptions.RepeatBehavior
    
    // 周期性动画，可指定次数和延迟
    static func periodic(_ count: Int? = nil, delay: Double? = nil) -> SymbolEffectOptions.RepeatBehavior
    
    // 连续动画，更平滑的无限循环
    static var continuous: SymbolEffectOptions.RepeatBehavior
}
```

示例：

```
// 无限循环，周期性播放
let options = SymbolEffectOptions.repeat(.periodic)

// 播放 5 次，每次间隔 1 秒
let options2 = SymbolEffectOptions.repeat(.periodic(5, delay: 1))

// 无限循环，使用平滑连续动画
let options3 = SymbolEffectOptions.repeat(.continuous)
```

- **periodic**：每次播放完成后间隔一段时间再开始，适合节奏感明显的动画
- **continuous**：动画从开始到结束平滑衔接，适合呼吸、闪烁等连续效果

#### 3. 默认值

- `SymbolEffectOptions.default`：默认速度 1.0，播放行为根据动画类型决定
- `SymbolEffectOptions.repeating`：偏好无限循环
- `SymbolEffectOptions.nonRepeating`：只播放一次



#### 4. 链式调用

这些选项可以链式调用：

```
imageView.addSymbolEffect(.pulse, options: .speed(1.5).repeating)
```



##  Bounce 动画

```
public struct BounceSymbolEffect : SymbolEffect
```

`BounceSymbolEffect` 是 **专门为 SF Symbols 设计的弹跳动画**。动画表现为 **沿 Y 轴的跳动运动**，可以向上或向下弹跳。

> ⚠️ 注意：**方向只能单向设置**，API 并不支持“先下再上”或者自定义上下顺序。



### 协议遵循与配置能力

- **SymbolEffect**
  - 拥有 **配置能力**（`configuration`），用于描述动画参数，如重复次数、速度等。
  - 可直接在 UIKit / SwiftUI 中使用统一接口，例如：`addSymbolEffect()` / `.symbolEffect()`。
- **DiscreteSymbolEffect**
  - 一次性动画（瞬态动画），播放完成即结束。
- **IndefiniteSymbolEffect**
  - 持续动画（无限循环），直到被移除或禁用。
  - 可通过 `SymbolEffectOptions.repeating` 设置循环播放。

### 方向控制

```
public var up: BounceSymbolEffect { get }
public var down: BounceSymbolEffect { get }
```

* `up` : 符号向上弹跳

* `down`: 符号向下弹跳

```
// 向上弹跳，慢速，循环
imageView2.addSymbolEffect(.bounce.up, options: .repeating.speed(0.1) )
```

> ⚠️ 单向设置：无法一次周期实现先下后上的效果。

### 层级控制

```
public var byLayer: BounceSymbolEffect { get }
public var wholeSymbol: BounceSymbolEffect { get }
```

* `byLayer`:  对每个 motion group（符号内部可单独动画的部分）分别应用动画

* `wholeSymbol`:  同时作用于所有 motion group

```
// 每个层单独跳动，向上，循环
imageView.addSymbolEffect(.bounce.byLayer.up, options: .repeating.speed(0.1))

// 整个符号同时跳动，向下，循环
imageView.addSymbolEffect(.bounce.wholeSymbol.down, options: .repeating.speed(0.5))
```

### 补充信息

1. **默认播放类型**
   - Bounce 默认是一种 **一次性动画**（Discrete），通过 options 可改为无限循环（Indefinite）。
2. **与 Pulse / VariableColor 区别**
   - Bounce 主要表现为 **位移弹跳**
   - Pulse / VariableColor 更多是 **透明度或颜色变化**
3. **可组合链式调用**
   - `.bounce.byLayer.up` 这样的链式调用非常灵活，可以先选择层级，再选择方向
   - 但方向链无法混合顺序（无法 `.up.down`）。



## Pulse 动画

```
public struct PulseSymbolEffect : SymbolEffect
```

`PulseSymbolEffect` 是 **专门为 SF Symbols 设计的脉冲动画**，动画表现为 **符号或其部分图层的透明度周期性变化**，产生“呼吸”或“闪烁”的效果。

> ⚠️ 注意：Pulse 动画可以既作为一次性动画（Discrete）播放，也可以作为无限循环动画（Indefinite）使用，取决于 `SymbolEffectOptions` 的配置。

### 协议遵循与配置能力

- **SymbolEffect**
  - 拥有 **配置能力**（`configuration`），用于描述动画参数，如重复次数、速度等。
  - 可直接在 UIKit / SwiftUI 中使用统一接口，例如：`addSymbolEffect()` / `.symbolEffect()`。
- **DiscreteSymbolEffect**
  - 一次性脉冲动画（瞬态），播放完成即结束。
- **IndefiniteSymbolEffect**
  - 持续脉冲动画（无限循环），直到被移除或禁用。
  - 可通过 `SymbolEffectOptions.repeating` 设置循环播放。

### 动画控制

```
public var byLayer: PulseSymbolEffect { get }
public var wholeSymbol: PulseSymbolEffect { get }
```

- `.byLayer` → 对每个 **motion group**（符号内部可独立动画的部分）分别应用脉冲动画
- `.wholeSymbol` → 同时作用于所有 motion group

示例：

```
// 整个符号同时脉冲，慢速循环
imageView.addSymbolEffect(.pulse.wholeSymbol, options: .repeating.speed(0.5))

// 每个层单独脉冲，快速循环
imageView.addSymbolEffect(.pulse.byLayer, options: .repeating.speed(2.0))

// 一次性脉冲动画（播放一次即可）
imageView.addSymbolEffect(.pulse.wholeSymbol, options: .nonRepeating.speed(1.0))
```



### 补充信息

1. **默认播放类型**
   - Pulse 默认可以作为 **一次性动画**（Discrete）。
2. **与 Bounce / VariableColor 区别**
   - Pulse 主要表现为 **透明度闪烁/呼吸效果**
   - Bounce 表现为 **位移弹跳**
   - VariableColor 表现为 **颜色渐变变化**
3. **可组合链式调用**
   - `.pulse.byLayer` 或 `.pulse.wholeSymbol` 可灵活组合
   - 还可通过 `SymbolEffectOptions.speed`、`.repeating` 等链式设置动画节奏与重复方式



## Scale 动画

```
public struct ScaleSymbolEffect : SymbolEffect
```

`ScaleSymbolEffect` 是 **专门为 SF Symbols 设计的缩放动画效果**。
动画表现为 **沿符号中心的缩放运动**，可以“放大”或“缩小”，常用于强调状态变化或制作呼吸效果。

> ⚠️ 注意：Scale 只能设置单向状态（up 或 down），不会自动循环，也没有离散动画（Discrete）选项。动画会保持在设置的缩放状态，直到开发者手动移除或改变。

### 协议遵循与配置能力

- **SymbolEffect**
  - 拥有 **配置能力** (`configuration`)，用于描述动画参数，如速度等。
  - 可直接在 UIKit / SwiftUI 中使用统一接口，例如：`addSymbolEffect()` / `.symbolEffect()`。
- **IndefiniteSymbolEffect**
  - 表示动画会 **持续保持在指定状态**（up 或 down），不会自动来回循环。
  - 可通过 `SymbolEffectOptions` 设置速度或其他参数。
  - 需要开发者手动终止或移除动画。

### 方向控制

```
public var up: ScaleSymbolEffect { get }
public var down: ScaleSymbolEffect { get }
```

- `up` : 符号保持放大状态
- `down`: 符号保持缩小状态

```
// 放大符号，慢速
imageView.addSymbolEffect(.scale.up, options: .speed(0.3))
```



### 层级控制

```
public var byLayer: ScaleSymbolEffect { get }
public var wholeSymbol: ScaleSymbolEffect { get }
```

- `byLayer` : 对符号内部可单独动画的部分分别应用缩放状态
- `wholeSymbol` : 整个符号统一缩放

```
// 每个层分别放大
imageView.addSymbolEffect(.scale.byLayer.up, options: .speed(0.3))

// 整个符号同时缩小
imageView.addSymbolEffect(.scale.wholeSymbol.down, options: .speed(0.5))
```

### 补充信息

1. **默认播放类型**
   - Scale 默认是 **持续状态动画**，不会自动来回循环。
   - 可以通过 `SymbolEffectOptions.speed()` 调整缩放变化的过渡速度。
2. **与 Bounce / Pulse 区别**
   - Scale 主要表现为 **符号整体或部分缩放**
   - Bounce / Pulse 更强调 **位置或透明度/亮度变化**。
3. **可组合链式调用**
   - `.scale.byLayer.up` 或 `.scale.wholeSymbol.down` 可以灵活组合层级和方向
   - 但无法实现自动循环或先放大再缩小的效果。



## Variable Color 动画

```swift
public struct VariableColorSymbolEffect : SymbolEffect
```

`VariableColorSymbolEffect` 是 **为 SF Symbols 可变颜色图层设计的动画效果**。它通过改变符号图层的透明度或亮度，实现 **颜色动态变化**。对普通（非可变颜色）符号无效。

> 可在 **SF Symbol App** 中查看符号属性是否支持。

### 协议遵循与配置能力

- **SymbolEffect**
  - 拥有 **配置能力** (`configuration`) 用于描述动画参数
  - 可直接在 UIKit / SwiftUI 中使用统一接口，例如：`addSymbolEffect()` / `.symbolEffect()`。
- **DiscreteSymbolEffect**
  - 一次性动画（瞬态动画），播放完成即结束
- **IndefiniteSymbolEffect**
  - 持续动画（无限循环），直到被移除或禁用
  - 可通过 `SymbolEffectOptions.repeating` 设置循环播放

### 方向控制

```
public var reversing: VariableColorSymbolEffect { get }
public var nonReversing: VariableColorSymbolEffect { get }
```

- **reversing** （反转）
  - 每次动画循环时方向反转（类似“往返运动”）
  - 举例：第一周期从底到顶，第二周期从顶到底
  - 常用于 **动画更自然的循环**
- **nonReversing**（非反转）
  - 每次循环保持同样方向
  - 第一周期底到顶，第二周期又从底到顶
  - 用于 **单向上升或下降效果**

**组合示例：**

```
.imageView.addSymbolEffect(.variableColor.reversing.iterative, options: .repeating)
```

> 解释：迭代模式下，每次循环方向反转



### 层级控制

```
public var cumulative: VariableColorSymbolEffect { get }
public var iterative: VariableColorSymbolEffect { get }
```

- **cumulative** （累积）
  - 每个 successive layer 激活后保持激活，直到整个动画周期结束
  - 视觉效果：每个层依次亮起，亮起的层不会熄灭，形成 **累积叠加** 效果
- **iterative** （逐层）
  - 每个 successive layer 临时激活一小段时间，然后恢复未激活状态
  - 视觉效果：每个层依次闪动，形成 **轮流闪烁** 效果

> ⚠️ 这两者互斥，调用其中一个会取消另一个效果。

**组合示例：**

```
// 累积模式 + 渐暗未激活层
imageView.addSymbolEffect(.variableColor.cumulative.dimInactiveLayers, options: .repeating)

// 迭代模式 + 隐藏未激活层
imageView.addSymbolEffect(.variableColor.iterative.hideInactiveLayers, options: .repeating)
```



### 非激活层显示方式

```
public var hideInactiveLayers: VariableColorSymbolEffect { get }
public var dimInactiveLayers: VariableColorSymbolEffect { get }
```

- **hideInactiveLayers**
  - 未激活的图层完全隐藏（opacity = 0）
  - 用于强调当前激活的图层
- **dimInactiveLayers**
  - 未激活的图层显示为较低透明度（0 < opacity < 1）
  - 保留符号整体形状的可见性，同时突出活跃层

**组合示例：**

```
// 迭代模式，每次仅显示激活层
imageView.addSymbolEffect(.variableColor.iterative.hideInactiveLayers, options: .repeating)

// 累积模式，保持前面激活的层可见，但非激活层渐暗
imageView.addSymbolEffect(.variableColor.cumulative.dimInactiveLayers, options: .repeating)
```



### 属性组合示意

Variable Color 的属性可以自由组合，形成不同视觉效果：

| 属性组合                          | 含义                                       | 举例                                     |
| --------------------------------- | ------------------------------------------ | ---------------------------------------- |
| `iterative + hideInactiveLayers`  | 每个图层依次短暂亮起，非激活层完全隐藏     | 层轮流闪烁，突出活跃层                   |
| `iterative + dimInactiveLayers`   | 每个图层依次短暂亮起，非激活层保持低透明度 | 层轮流闪烁，但符号轮廓可见               |
| `cumulative + hideInactiveLayers` | 激活的层累积显示，非激活层隐藏             | 前层亮起，后续层逐渐叠加出现             |
| `cumulative + dimInactiveLayers`  | 激活层累积显示，非激活层渐暗               | 前层亮起，整个符号轮廓可见，形成渐亮效果 |
| `reversing`                       | 循环时动画方向反转                         | 往返闪烁更自然                           |
| `nonReversing`                    | 循环时保持方向一致                         | 单向闪烁或累积效果                       |

> ⚠️ 注意：`cumulative` 与 `iterative` 互斥；`reversing` / `nonReversing` 与层级控制可自由组合；`hideInactiveLayers` 与 `dimInactiveLayers` 也互斥。





### 补充信息

1. **默认播放类型**
   - Variable Color 可以同时作为 **离散动画** 或 **持续动画**
   - 对可变颜色符号有效，对普通符号无效
2. **与 Bounce / Scale / Pulse 区别**
   - Variable Color 主要改变 **符号图层颜色或透明度**
   - Bounce / Scale / Pulse 更强调 **位移或缩放/透明度变化**
3. **可组合链式调用**
   - `.variableColor.reversing.cumulative.hideInactiveLayers` 等链式调用可自由组合模式和可见性



## Wiggle 动画

```
public struct WiggleSymbolEffect : SymbolEffect
```

`WiggleSymbolEffect` 是 **专门为 SF Symbols 设计的摇摆动画**。动画表现为 **沿 X 或 Y 轴的小幅往复运动**，或者旋转往复运动，用于提示或强调符号。

### 协议遵循与配置能力

- **SymbolEffect**
  - 拥有 **配置能力** (`configuration`)，可用于设置动画参数，例如速度和重复次数。
  - 可直接在 UIKit / SwiftUI 中使用统一接口，例如：`addSymbolEffect()` / `.symbolEffect()`。
- **DiscreteSymbolEffect**
  - 一次性动画（瞬态），播放完成即结束。
- **IndefiniteSymbolEffect**
  - 持续动画（无限循环），直到被移除或禁用。
  - 可通过 `SymbolEffectOptions.repeating` 或默认行为播放。

### 方向控制

```
// 水平移动
public var left: WiggleSymbolEffect
public var right: WiggleSymbolEffect

// 垂直移动
public var up: WiggleSymbolEffect
public var down: WiggleSymbolEffect

// 顺时针 / 逆时针旋转
public var clockwise: WiggleSymbolEffect
public var counterClockwise: WiggleSymbolEffect

// 根据当前语言环境水平移动
public var forward: WiggleSymbolEffect
public var backward: WiggleSymbolEffect

// 自定义任意角度移动（顺时针为正角度）
public func custom(angle: Double) -> WiggleSymbolEffect
```

> ⚠️ 注意：
>
> - 每个方向都是 **起始方向**，动画周期会在起始方向和反方向之间往返。
> - 例如 `.left` 意味着先向左，然后往右，再回到原位。

### 层级控制

```
public var byLayer: WiggleSymbolEffect
public var wholeSymbol: WiggleSymbolEffect
```

- `byLayer`: 对符号每个 motion group 分别应用动画
- `wholeSymbol`: 对整个符号同时应用动画

```
// 整个符号摇摆
imageView.addSymbolEffect(.wiggle.wholeSymbol.left, options: .repeating.speed(0.5))

// 每层摇摆
imageView.addSymbolEffect(.wiggle.byLayer.clockwise, options: .repeating.speed(0.2))
```

### 补充信息

1. **默认播放类型**
   - Wiggle 默认是持续动画（Indefinite），无需额外设置即可循环播放。
   - 若想只播放一次，可使用 `.nonRepeating` 或限制重复次数。
2. **可组合链式调用**
   - `.wiggle.byLayer.left` 或 `.wiggle.wholeSymbol.clockwise` 可与速度、重复选项组合。
   - 可自定义角度：`.wiggle.custom(angle: 30)`。

## Appear 动画

让 SF Symbol 从某个方向逐渐出现，可配合 `byLayer` 或 `wholeSymbol` 设置显示层级。

> ⚠️ 默认是一次性动画（Discrete），播放完成即结束。
>
> 如果符号本身已经显示出来，再播放 Appear 动画，视觉上是看不到任何变化的。
>
> **最好是结合Disappear动画一起使用**

```
public struct AppearSymbolEffect : SymbolEffect {
    public var up: AppearSymbolEffect { get }        // 从下向上出现
    public var down: AppearSymbolEffect { get }      // 从上向下出现
    public var byLayer: AppearSymbolEffect { get }  // 每个 motion group 分别出现
    public var wholeSymbol: AppearSymbolEffect { get } // 整个符号同时出现
}
```

**方向控制**：

- `.up`：符号从下方出现
- `.down`：符号从上方出现

**层级控制**：

- `.byLayer`：符号内部各 motion group 分别出现
- `.wholeSymbol`：整个符号同时出现

**默认行为**：一次性动画（Discrete），播放完成即结束

```
imageView1.addSymbolEffect(.appear.up.wholeSymbol, options: .speed(0.5))
imageView2.addSymbolEffect(.appear.down.byLayer, options: .speed(0.8))
imageView3.addSymbolEffect(.appear.up.byLayer, options: .speed(1.0))
```



## Disappear 动画

让 SF Symbol 向某个方向消失，可配合 `byLayer` 或 `wholeSymbol` 设置消失层级。

> 默认是一次性动画（Discrete），播放完成即结束。

```
public struct DisappearSymbolEffect : SymbolEffect {
    public var up: DisappearSymbolEffect { get }       
    public var down: DisappearSymbolEffect { get }     
    public var byLayer: DisappearSymbolEffect { get }  
    public var wholeSymbol: DisappearSymbolEffect { get } 
}
```

**方向控制**：

- `.up`：符号向上消失
- `.down`：符号向下消失

**层级控制**：

- `.byLayer`：符号内部各 motion group 分别消失
- `.wholeSymbol`：整个符号同时消失

```
imageView1.addSymbolEffect(.disappear.up.wholeSymbol, options: .speed(0.5))
imageView2.addSymbolEffect(.disappear.down.byLayer, options: .speed(0.8))
imageView3.addSymbolEffect(.disappear.up.byLayer, options: .speed(1.0))
```





## Replace 动画

替换符号动画，常用于切换图标。

> 默认是一次性动画（Discrete）

```
public struct ReplaceSymbolEffect : SymbolEffect {
    public var downUp: ReplaceSymbolEffect { get }  // 旧符号缩小消失，新符号放大出现
    public var upUp: ReplaceSymbolEffect { get }    // 旧符号放大消失，新符号放大出现
    public var offUp: ReplaceSymbolEffect { get }   // 旧符号直接消失，新符号放大出现
    public var byLayer: ReplaceSymbolEffect { get } 
    public var wholeSymbol: ReplaceSymbolEffect { get }
}
```

**变体**：

- `.downUp`：旧符号缩小消失 → 新符号放大出现
- `.upUp`：旧符号放大消失 → 新符号放大出现
- `.offUp`：旧符号直接消失 → 新符号放大出现

**层级控制**：

- `.byLayer`：每个 motion group 分别动画
- `.wholeSymbol`：整个符号同时动画

```
// 由 暂停 → 播放 替换动画效果
imageView.image = UIImage(systemName: "pause.fill")
DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
   let palyImage = UIImage(systemName: "play.fill")!
   self.imageView.setSymbolImage(palyImage, contentTransition: .replace.offUp)
}
```



## Rotate 动画

```
public struct RotateSymbolEffect : SymbolEffect
```

`RotateSymbolEffect` 是 **专门为 SF Symbols 设计的旋转动画**。
动画表现为 **围绕 Z 轴（中心点）旋转**，可选择顺时针或逆时针方向。

### 协议遵循与配置能力

- **SymbolEffect**
  - 支持 `configuration` 配置，控制动画的速度、次数、是否循环等。
  - 可在 UIKit / SwiftUI 中直接使用：`addSymbolEffect()` / `.symbolEffect()`。
- **DiscreteSymbolEffect**
  - 默认是一次性动画。
- **IndefiniteSymbolEffect**
  - 可通过 `.repeating` 转为无限循环。



### 方向控制

```
public var clockwise: RotateSymbolEffect { get }
public var counterClockwise: RotateSymbolEffect { get }
```

- `clockwise`：顺时针旋转
- `counterClockwise`：逆时针旋转

```
// 顺时针旋转，循环，速度 0.5
imageView.addSymbolEffect(.rotate.clockwise, options: .repeating.speed(0.5))

// 逆时针旋转，一次性
imageView.addSymbolEffect(.rotate.counterClockwise)
```

### 层级控制

```
public var byLayer: RotateSymbolEffect { get }
public var wholeSymbol: RotateSymbolEffect { get }
```

- `byLayer`: 每个 motion group 分别旋转
- `wholeSymbol`: 整个符号整体旋转

```
// 每层分别旋转，顺时针，循环
imageView.addSymbolEffect(.rotate.byLayer.clockwise, options: .repeating)

// 整体逆时针旋转，慢速循环
imageView.addSymbolEffect(.rotate.wholeSymbol.counterClockwise, options: .repeating.speed(0.3))
```



### 补充信息

1. **默认是瞬态动画**（Discrete），需要 `.repeating` 才能持续。
2. **适合指示加载**，比如“旋转中的 Wi-Fi、刷新箭头”等。
3. **与 Bounce 的区别**：Rotate 是角度变化，Bounce 是位移弹跳。
4. **链式组合**：可先选层级 `.byLayer` 再选方向 `.clockwise`，灵活配置。

## Breathe 动画

```
public struct BreatheSymbolEffect : SymbolEffect
```

`BreatheSymbolEffect` 是 **SF Symbols 专用的呼吸动画**。
表现为 **符号逐渐放大/缩小、透明度变化**，模拟“呼吸”效果。



### 协议遵循与配置能力

- **SymbolEffect**
  - 同样支持速度、重复等配置。
- **IndefiniteSymbolEffect**
  - Breathe 更常用于 **无限循环** 的持续效果。



### 呼吸样式

```
public var pulse: BreatheSymbolEffect { get }
public var plain: BreatheSymbolEffect { get }
```

- `pulse`：带脉冲感的呼吸动画（更明显的缩放和透明度变化）
- `plain`：基础的呼吸动画（轻微变化，更自然）

```
// 脉冲型呼吸，循环播放
imageView.addSymbolEffect(.breathe.pulse, options: .repeating)

// 普通呼吸动画，慢速
imageView.addSymbolEffect(.breathe.plain, options: .repeating.speed(0.3))
```



### 层级控制

```
public var byLayer: BreatheSymbolEffect { get }
public var wholeSymbol: BreatheSymbolEffect { get }
```

- `byLayer`：每个 motion group 独立呼吸
- `wholeSymbol`：符号整体呼吸

```
// 每层分别呼吸，pulse 效果，循环
imageView.addSymbolEffect(.breathe.byLayer.pulse, options: .repeating)

// 整个符号呼吸，plain 效果
imageView.addSymbolEffect(.breathe.wholeSymbol.plain, options: .repeating)
```



### 补充信息

1. **默认更适合持续动画**，常用于强调状态（比如心跳、提醒）。
2. **Pulse 与 Plain 的区别**：Pulse 动态更强烈，Plain 更轻柔。
3. **与 Rotate / Bounce 区别**：Breathe 偏向缩放与透明度，Rotate 偏向角度变化，Bounce 偏向位移运动。



## 动画的组合使用

你可以在同一个 `UIImageView` 或 `SymbolImageView` 上 **同时叠加多种动画**，动画之间互不冲突，可以组合出丰富的效果。例如：

```
imageView.addSymbolEffect(.wiggle.wholeSymbol.left, options: .repeating.speed(0.5))
imageView.addSymbolEffect(.variableColor.cumulative, options: .repeating.speed(0.3))
```

### 注意事项：

1. **独立类型可组合**
   - 不同类型的动画（如 `wiggle`、`scale`、`bounce`、`variableColor`）可以同时叠加。
   - 同类型动画如果叠加，后添加的会覆盖前一个动画。
2. **顺序与延迟**
   - 组合动画时，如果希望产生时间错位的视觉效果，可以使用 `DispatchQueue.main.asyncAfter` 或 `UIViewPropertyAnimator` 配合触发。
3. **层级控制**
   - 可以针对每个动画单独设置 `.byLayer` 或 `.wholeSymbol`，实现局部或整体效果。
4. **性能考虑**
   - 多个动画同时运行会增加 CPU/GPU 消耗，尤其是在旧设备上，建议合理控制动画数量和复杂度。





## 动画的停止

可以根据需要 **手动停止动画**，提供了两种方式：

### 1. 停止某种类型的动画

```
// 停止指定类型的动画，例如停止 Scale 动画
imageView.removeSymbolEffect(ofType: .scale)
```

- `ofType` 支持所有 conform `SymbolEffect` 的类型，例如 `wiggle`  , `variableColor` 等。
- 仅停止指定类型，不影响同一视图上其他类型动画。

### 2. 停止所有动画

```
// 停止该 imageView 上的所有 Symbol 动画
imageView.removeAllSymbolEffects()
```

- 立即停止所有已添加的动画，并恢复到符号默认状态（不改变 image 本身）。
- 对于正在播放的无限循环动画（如 `VariableColor`、`Wiggle`、`Scale`），这是唯一快速终止方式。

### 3. 补充提示

- 停止动画并不会隐藏符号，如果希望消失或替换，需要手动设置 `imageView.alpha` 或更改 `imageView.image`。
- 对离散动画（DiscreteSymbolEffect）调用停止时，如果动画已完成播放，调用不会产生副作用。
